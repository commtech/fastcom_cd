Connecting the FSCC up to an IP network using PPP.

Note: Much of what follows has been found to work for us here in a lab
environment.  We do not claim to be experts in PPP networking.  If there is
anything that we suggest doing that doesn't work or that you believe is in
error, we apologize.

Prereqs:

Compile PPP support into the kernel (or as modules), select (at a minimum?)

'PPP (point-to-point protocol) Support'
'PPP Support for async serial ports'
'PPP BSD Deflate compression'
'PPP Deflate compression'

the resulting modules that are needed are:

slhc
ppp_generic
ppp_async
bsd_comp
ppp_deflate

The pty.c in this directory has been adjusted to give a maximum frame size of
BUFSIZ (which on my system is 8k).

There is currently no error handling/recovery in the pty wedge program for the 
FSCC.  If an error occurs while reading/writing to the FSCC the pty wedge will terminate,
and the link will close.


Kernel 2.4 
-------------------------------

With these modules in place, you can build the fscc driver module.

Uncompress the fscc sources:

   tar -xzvf fsccp_xxx.tar.gz

Change into the module source directory:

   cd fsccp

Create the fsccp.o module:

   make -f Makefile_2.4

Load the esccp.o module and create the devnodes:

   ./mkdev_2.4.sh

Change into the example code directory:

   cd utils

Build the examples:

   make
   make install

Configure the card/port:

   cd bin
   ./setclock 0 10000000
   ./setfscc 0 ../ppp/hdlcset_for_ppp

Execute the pty wedge program:

   ./pty /dev/fscc0

This will return something like '/dev/pts/0', substitute the result into the 
following line for '/dev/pts/x'  (also substitute any valid parameters to pppd 
here including the IP's that you really want)

   pppd -detach local 192.168.2.50:192.168.2.51 /dev/pts/x &

Execute an identical sequence on second PC swapping the IP addresses in the last
command.  You need to execute the pppd command at about the same time on both
PC's as it will timeout if it does not get a response from the other side.

Note that there was a full crossover cable RD->SD TT->RT both directions in 
place between the two boards.  The above settings uses clock mode 1, and is 
running at 10Mbps.

Running 'ifconfig' should show ppp0 with IP's on both sides.

Things like

   ping 192.168.2.51 

should now work, as should any other IP related utility (ie setup routing, 
gateways etc, scp, ftp, etc)

This was tested with a stock redhat 9.0 install.


Kernel 2.6 
-------------------------------

With these modules in place, you can build the fscc driver module.

Uncompress the fscc sources:

   tar -xzvf fsccp_xxx.tar.gz

Change into the module source directory:

   cd fsccp

Create the fsccp.ko module:

   make Makefile_2.6

Load the esccp.o module and create the devnodes:

   ./mkdev.sh

Change into the example code directory:

   cd utils

Build the examples:

   make
   make install

Configure the card/port:

   cd bin
   ./setclock 0 10000000
   ./setfscc 0 ../ppp/hdlcset_for_ppp

Execute the pty wedge program:

   ./pty /dev/fscc0

This will return something like 'using: /dev/pts/0', substitute the result into 
the following line for '/dev/pts/x'  (also substitute any valid parameters to 
pppd here including the IP's that you really want)

   pppd up detach local nobsdcomp /dev/pts/x 192.168.2.50:192.168.2.51 &

Execute an identical sequence on second PC swapping the IP addresses in the last
command.  You need to execute the pppd command at about the same time on both
PC's as it will timeout if it does not get a response from the other side.

Note that there was a full crossover cable RD->SD TT->RT both directions in 
place between the two boards.  The above settings uses clock mode 1, and is 
running at 10Mbps.

Running 'ifconfig' should show ppp0 with IP's on both sides.

Things like

   ping 192.168.2.51 

should now work, as should any other IP related utility (ie setup routing, 
gateways etc, scp, ftp, etc)

